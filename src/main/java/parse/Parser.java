/* Parser.java */
/* Generated by: ParserGeneratorCC: Do not edit this line. Parser.java */
package parse;

public class Parser implements ParserConstants {
  public static String parse(String args) throws Exception
  {
    Parser parse = new Parser(new java.io.StringReader(args));
    String rst = parse.Query();
    return rst;
  }

/*

start the query, call SFWStatement() and add "<dbQuery>""</dbQuery>" out of the SFWStatement.

*/
  final public String Query() throws ParseException {String rst;
    rst = SFWStatement();
    jj_consume_token(0);
{if ("" != null) return "<dbQuery>" + rst + "</dbQuery>";}
    throw new IllegalStateException ("Missing return statement in function");
}

/*

first check the select clause
then check the from clause
finally check the where clause

*/
  final public String SFWStatement() throws ParseException {String select = "";
  String from = "";
  String where = "";
    select = SelectClause();
    from = FromClause();
    where = WhereClause();
{if ("" != null) return "<dbSFWStatement>" + select + from + where + "</dbSFWStatement>";}
    throw new IllegalStateException ("Missing return statement in function");
}

/*

this is the select clause, we need to find all the attribute so we call Attr method

*/
  final public String SelectClause() throws ParseException {String select;
    jj_consume_token(SELECT);
    select = Attr();
{if ("" != null) return "<dbSelectClause>" + select + "</dbSelectClause>";}
    throw new IllegalStateException ("Missing return statement in function");
}

/*

this method will recursively find all the attribute in the select clause and return all the attribute as one String.

*/
  final public 
String Attr() throws ParseException {Token relation;
  Token attr;
  String subAttr = "";
    relation = jj_consume_token(NAME);
    jj_consume_token(DOT);
    attr = jj_consume_token(NAME);
    label_1:
    while (true) {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case COMMA:{
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      jj_consume_token(COMMA);
      subAttr = Attr();
    }
{if ("" != null) return "<dbAttr>" + "<dbRelVar> <dbRelAliasName Token=\"" + relation.image + "\" /> </dbRelVar>" + "<dbAttrName Token=\"" + attr.image + "\" /> " + "</dbAttr>" + subAttr;}
    throw new IllegalStateException ("Missing return statement in function");
}

/*

this is the from clause, we will call RelVal() method to find all relations

*/
  final public 
String FromClause() throws ParseException {String from;
    jj_consume_token(FROM);
    from = RelVal();
{if ("" != null) return "<dbFromClause>" + from + "</dbFromClause>";}
    throw new IllegalStateException ("Missing return statement in function");
}

/*

this method will find all the relations in the from clause

*/
  final public 
String RelVal() throws ParseException {Token realName;
  Token aliasName;
  String subVal = "";
    realName = jj_consume_token(NAME);
    aliasName = jj_consume_token(NAME);
    label_2:
    while (true) {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case COMMA:{
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      subVal = RelVal();
    }
{if ("" != null) return "<dbRelVar>" + "<dbRelName Token=\"" + realName.image + "\" />" + "<dbRelAliasName Token=\"" + aliasName.image + "\" /> </dbRelVar>" + subVal;}
    throw new IllegalStateException ("Missing return statement in function");
}

/*

next is the where clause. It will have several recursion next in this method.
First we call Expression and assign false to represent that this is the first time we call it, So it must add <BooleanExp><\BooleanExp> out of the where clause abstract syntex tree

*/
  final public 
String WhereClause() throws ParseException {String where = "";
    jj_consume_token(WHERE);
    where = Expression(false);
{if ("" != null) return "<dbWhereClause>" + where + "</dbWhereClause>";}
    throw new IllegalStateException ("Missing return statement in function");
}

/*

this method will find all the boolean factors and add BooleanExp in the case we have more than two boolean factors or has parenthesis in some of the boolean factors.

*/
  final public 
String Expression(boolean hasFather) throws ParseException {String exp1 = "";
  String exp2 = "";
    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
    case OPEN_PAR:{
      jj_consume_token(OPEN_PAR);
      exp1 = Expression(true);
      jj_consume_token(CLOSE_PAR);
      label_3:
      while (true) {
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case AND:{
          break;
          }
        default:
          jj_la1[2] = jj_gen;
          break label_3;
        }
        jj_consume_token(AND);
        exp2 = Expression(true);
      }
/* if hasFather == true means we have the <BooleanExp></BooleanExp> out of this time's call.
    	then we check if exp2 is empty. if exp2 is empty after the parsing. This means this time is the final BooleanFactor in this BooleanExpression and we don't want to have a single BooleanFactor in the BooleanExp, so we will not add "<BooleanExp>"..."</BooleanExp>" out of it.
    */
    if (hasFather == true && exp2.equals(""))
    {
      {if ("" != null) return exp1;}
    }
    /* if it has no father parenthesis out of it or exp2 not empty, we need to add the BooleanExp out of exp1 + exp2*/
    {if ("" != null) return "<BooleanExp>" + exp1 + exp2 + "</BooleanExp>";}
      break;
      }
    case QUO:
    case DIGITS:
    case NAME:{
      exp1 = Factor();
      label_4:
      while (true) {
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case AND:{
          break;
          }
        default:
          jj_la1[3] = jj_gen;
          break label_4;
        }
        jj_consume_token(AND);
        exp2 = Expression(true);
      }
/*the next check has the same function as the previous checking*/
    if (hasFather == true && exp2.equals(""))
    {
      {if ("" != null) return exp1;}
    }
    else
    {
      {if ("" != null) return "<BooleanExp>" + exp1 + exp2 + "</BooleanExp>";}
    }
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new IllegalStateException ("Missing return statement in function");
}

/*

this method will parse the Boolean factor. It can be three situation.
1. it is a table.Attribute. such as "Emp.Name = Dep.MName"
2. it is a string literal. such as "Emp.Name = "james""
3. it is a integer literal. such as "Emp.Salary = 7000"
So we can find all three situation has a left part and and an operation and a right part.

*/
  final public 
String Factor() throws ParseException {String left = "";
  String right = "";
  String operator;
    /*so we parse the left, right and operator one by one*/
      left = BooleanAttr();
    operator = Operator();
    right = BooleanAttr();
{if ("" != null) return "<BooleanFactor>" + left + operator + right + "</BooleanFactor>";}
    throw new IllegalStateException ("Missing return statement in function");
}

/*

the attribute can have three situation as well.
1. name.name such as "Emp.Name"
2. String Literal such as "James"
3. Integer Literal such as 7000

so this method will check them and return the corresponding attribute

*/
  final public 
String BooleanAttr() throws ParseException {Token rel;
  Token attr;
  String attrName = "";
    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
    case DIGITS:{
      rel = jj_consume_token(DIGITS);
{if ("" != null) return "<dbConstValue> <INTEGERLITERAL Token=\"" + rel.image + "\"/> </dbConstValue>";}
      break;
      }
    case NAME:{
      rel = jj_consume_token(NAME);
      jj_consume_token(DOT);
      attr = jj_consume_token(NAME);
{if ("" != null) return "<dbAttr>" + "<dbRelVar> <dbRelAliasName Token=\"" + rel.image + "\" /> </dbRelVar>" + "<dbAttrName Token=\"" + attr.image + "\" /> </dbAttr>";}
      break;
      }
    case QUO:{
      jj_consume_token(QUO);
      rel = jj_consume_token(NAME);
      jj_consume_token(QUO);
{if ("" != null) return "<dbConstValue><STRINGLITERAL Token=\"" + rel.image + "\"/> </dbConstValue>";}
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new IllegalStateException ("Missing return statement in function");
}

/*this method will check the operator and return it as it is. */
  final public 
String Operator() throws ParseException {Token operator;
    operator = jj_consume_token(OPERATOR);
{if ("" != null) return "<comparisonOp Token=\"" + operator.image + "\" />";}
    throw new IllegalStateException ("Missing return statement in function");
}

  /** Generated Token Manager. */
  public ParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[6];
  static private int[] jj_la1_0;
  static {
	   jj_la1_init_0();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x1000,0x1000,0x100,0x100,0x1a200,0x1a000,};
	}

  /**
   * Constructor with InputStream.
   * @param stream input stream
   */
  public Parser(final java.io.InputStream stream) {
	  this(stream, null);
  }

  /**
   * Constructor with InputStream and supplied encoding
   * @param stream input stream
   * @param encoding charset to be used
   */
  public Parser(final java.io.InputStream stream, final String encoding) {
   try {
     jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
   } catch(final java.io.UnsupportedEncodingException e) {
     throw new IllegalStateException(e);
   }
	 token_source = new ParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  /**
   * Reinitialise
   * @param stream input stream
   */
  public void ReInit(final java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /**
   * Reinitialise
   * @param stream input stream
   * @param encoding charset to be used
   */
  public void ReInit(final java.io.InputStream stream, final String encoding) {
	  try {
      jj_input_stream.reInit(stream, encoding, 1, 1);
    } catch(final java.io.UnsupportedEncodingException e) { 
      throw new IllegalStateException(e);
    }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  /**
   * Constructor with InputStream.
   * @param stream char stream
   */
  public Parser(final java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new ParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
   for (int i = 0; i < 6; i++)
     jj_la1[i] = -1;
  }

  /**
   * Reinitialise
   * @param stream char stream
   */
  public void ReInit(final java.io.Reader stream) {
	if (jj_input_stream == null) {
	  jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	  jj_input_stream.reInit(stream, 1, 1);
  }
	if (token_source == null) {
 token_source = new ParserTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
   for (int i = 0; i < 6; i++)
     jj_la1[i] = -1;
  }

  /**
   * Constructor with generated Token Manager.
   * @param tm Token manager to use
   */
  public Parser(final ParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  /**
   * Reinitialise
   * @param tm Token manager to use
   */
  public void ReInit(final ParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(final int kind) throws ParseException {
    final Token oldToken = token;
    if (token.next != null)
      token = token.next;
    else {
      token.next = token_source.getNextToken();
      token = token.next;
    }
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


  /**
   * @return the next Token.
   */
  public final Token getNextToken() {
   if (token.next != null)
     token = token.next;
   else
     token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

  /**
   * @param index index to be retrieved
   * @return the specific Token.
   */
  public final Token getToken(final int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next == null)
        t.next = token_source.getNextToken();
      t = t.next;
    }
    return t;
  }

  private int jj_ntk_f() {
    jj_nt = token.next;
    if (jj_nt == null) {
      token.next = token_source.getNextToken();
      jj_ntk = token.next.kind;
      return jj_ntk;
    }
    jj_ntk = jj_nt.kind;
    return jj_ntk;
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /**
   * Generate ParseException.
   * @return new Exception object. Never <code>null</code>
   */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[17];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 6; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 17; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /**
   * @return Always <code>false</code>.
   */
  public final boolean trace_enabled() {
    return false;
  }

  /** Enable tracing. */
  public final void enable_tracing() {}

  /** Disable tracing. */
  public final void disable_tracing() {}

}
