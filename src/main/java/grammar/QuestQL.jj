/**
 *
 *
 */
/*

Options

*/
options{
    MULTI=true;
    NODE_DEFAULT_VOID=true;
    JAVA_TEMPLATE_TYPE="modern" ;
//  DEBUG_LOOKAHEAD= true ;
}

/*

Entry point

*/
PARSER_BEGIN(Parser)
package parse;

import io.questdb.griffin.model.ExpressionNode;
import io.questdb.std.ObjectPool;
import java.util.ArrayDeque;
import java.util.Deque;

public class Parser
{
  private ObjectPool<ExpressionNode> sqlNodePool = new ObjectPool<ExpressionNode>(ExpressionNode.FACTORY, 100);
  private final Deque<ExpressionNode> stack = new ArrayDeque<>();

  public static ExpressionNode parse(String args) throws Exception {
    Parser parse = new Parser(new java.io.StringReader(args));
    ExpressionNode rst = parse.SQLStatement();
    return rst;
  }

  public ExpressionNode collapseFunctionRightLeft(CharSequence name, ExpressionNode r, ExpressionNode l, Token token) {
    ExpressionNode parent = sqlNodePool.next().of(ExpressionNode.FUNCTION, name, Integer.MIN_VALUE, token.beginColumn);
    parent.rhs = r;
    parent.lhs = l;
    return parent;
  }
}

PARSER_END(Parser)

/*

set up tokens first. SKIP tokens of " ", "\t", "\r" and "\n"

*/
SKIP:
{
    " "
|   "\t"
|   "\r"
|   "\n"
}

/*

Quest SQL Keywords

*/
TOKEN:
{
    <K_ALL: "ALL">
|   <K_ALTER: "ALTER">
|   <K_AND: "AND">
|   <K_ANY: "ANY">
|   <K_AS: "AS">
|   <K_ASC:"ASC">
|   <K_BEGIN: "BEGIN">
|   <K_BETWEEN:"BETWEEN">
|   <K_BOOLEAN:"BOOLEAN">
|   <K_BY:"BY">
|   <K_CACHE:"CACHE">
|   <K_CASE:"CASE">
|   <K_CAST:"CAST">
|   <K_CHAR:"CHAR">
|   <K_CAPACITY:"CAPACITY">
|   <K_DATE:"DATE">
|   <K_DESC:"DESC">
|   <K_DISTINCT:"DISTINCT">
|   <K_DOUBLE:"DOUBLE">
|   <K_ELSE:"ELSE">
|   <K_END:"END">
|   <K_FLOAT:"FLOAT">
|   <K_FROM:"FROM">
|   <K_FULL:"FULL">
|   <K_IN:"IN">
|   <K_INDEX:"INDEX">
|   <K_INNER:"INNER">
|   <K_INTEGER:"INTEGER">
|   <K_INTO:"INTO">
|   <K_IS:"IS">
|   <K_LEFT:"LEFT">
|   <K_LIKE:"LIKE">
|   <K_NOCACHE: "NOCACHE">
|   <K_NOT:"NOT">
|   <K_NULL:"NULL">
|   <K_OR:"OR">
|   <K_ORDER:"ORDER">
|   <K_PARTITION:"PARTITION">
|   <K_SAMPLE:"SAMPLE">
|   <K_SELECT:"SELECT">
|   <K_SET:"SET">
|   <K_TABLE:"TABLE">
|   <K_UNION:"UNION">
|   <K_VALUES:"VALUES">
|   <K_STRING:"STRING">
|   <K_WHERE:"WHERE">
|   <K_WITH:"WITH">
}

TOKEN : /* Numeric Constants */
{
	< S_NUMBER: <FLOAT>
	    | <FLOAT> ( ["e","E"] ([ "-","+"])? <FLOAT> )?
    	>
  | 	< #FLOAT: <INTEGER>
	    | <INTEGER> ( "." <INTEGER> )?
	    | "." <INTEGER>
    	>
  | 	< #INTEGER: ( <DIGIT> )+ >
  | 	< #DIGIT: ["0" - "9"] >
}

SPECIAL_TOKEN:
{
   <LINE_COMMENT: "--"(~["\r","\n"])*>
|  <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN:
{
    < S_IDENTIFIER: (<LETTER>)+ (<DIGIT> | <LETTER> |<SPECIAL_CHARS>)* >
  | < #LETTER: ["a"-"z", "A"-"Z"] >
  | < #SPECIAL_CHARS: "$" | "_" | "#">
  | < S_BIND: ":" ( <S_NUMBER> | <S_IDENTIFIER> ("." <S_IDENTIFIER>)?) >
  | < S_CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
  | < S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" >
}

ExpressionNode BindVariable():
{}
{
    <S_BIND>
  | "$" (<S_NUMBER> | <S_IDENTIFIER>)
}

ExpressionNode BasicDataTypeDefinition():
{}
{
     "BOOLEAN"
    |   "BYTE"
    |   "SHORT"
    |   "CHAR"
    |   "INT"
    |   "FLOAT"
    |   "SYMBOL" //[<K_CAPACITY> <S_NUMBER> [<K_CACHE> | <K_NOCACHE>] [<K_INDEX> ]]
    |   "STRING"
    |   "LONG"
    |   "DATE"
    |   "TIMESTAMP"
    |   "DOUBLE"
    |   "BINARY"
    |   "LONG256"
}

ExpressionNode SQLStatement():
{}
{
    e = InsertStatement()
    |
    e = QueryStatement()
    { return e; }
}

void InsertStatement():
{}
{
    "INSERT" "INTO" TableName() {}
     [ LOOKAHEAD(2) "(" TableColumn() ("," TableColumn())* ")" ]
    ( "VALUES" "(" SqlExpressionList() ")"
      | SubQuery()
    )
    ";"
}

ExpressionNode QueryStatement():
{ExpressionNode e;}
{
    e = SelectStatement()
    ";"
    {return e;}
}

void SqlExpression():
{}
{
    r = SqlAndExpression() ("OR" l = SqlAndExpression() {
        ExpressionNode r1 = sqlNodePool.next().of(ExpressionNode.FUNCTION, "OR", Integer.MIN_VALUE, token.beginColumn);
        r1.rhs = r;
        r1.lhs = l;
        r = r1;
    })*
    { return jjtThis; }
}

ExpressionNode SqlAndExpression():
{ExpressionNode r, l;}
{
    r = SqlUnaryLogicalExpression() ( "AND" l = SqlUnaryLogicalExpression() {
        r = collapseFunctionRightLeft("AND", r, l, token);
    })*
    { return r; }
}

ExpressionNode SqlUnaryLogicalExpression():
{}
{
  ["NOT"] SqlRelationalExpression()
}

ExpressionNode SqlRelationalExpression():
{}
{
    SqlSimpleExpression()

    ( Relop() SqlSimpleExpression()
      |
      LOOKAHEAD(2) SqlInClause()
      |
      LOOKAHEAD(2) SqlBetweenClause()
      |
      LOOKAHEAD(2) SqlLikeClause()
      |
      IsNullClause()
   )?
}

ExpressionNode SqlExpressionList():
{}
{
    SqlExpression() ("," SqlExpression())*
}

ExpressionNode SqlInClause():
{}
{
    ["NOT"] "IN" "(" SqlExpressionList()")"
}

ExpressionNode SqlBetweenClause():
{}
{
    ["NOT"] "BETWEEN" SqlSimpleExpression() "AND" SqlSimpleExpression()
}

ExpressionNode SqlLikeClause():
{}
{
    ["NOT"] "LIKE" SqlSimpleExpression()
}

ExpressionNode IsNullClause():
{}
{
    "IS" ["NOT"] "NULL"
}

ExpressionNode SqlSimpleExpression():
{}
{
    SqlMultiplicativeExpression() ( ("+" | "-" | "||")
                                 SqlMultiplicativeExpression()
                               )*
}

ExpressionNode SqlMultiplicativeExpression():
{}
{
    SqlUnaryExpression() ( LOOKAHEAD(1) ("*" | "/" | ID("MOD")) SqlUnaryExpression())*
}

ExpressionNode SqlUnaryExpression():
{}
{
    (("+" | "-") SqlPrimaryExpression())
|
    SqlPrimaryExpression()
}

ExpressionNode SqlPrimaryExpression():
{}
{
    <S_NUMBER>
  | <S_CHAR_LITERAL>
  | "NULL"
  | SqlCaseExpression()
  | "(" (LOOKAHEAD(3) SelectStatement() | SqlExpression()) ")"
  | BindVariable()
  | LOOKAHEAD(2) SqlCastExpression()
  | LOOKAHEAD(IntervalExpression()) IntervalExpression()
  | LOOKAHEAD(2) (<S_IDENTIFIER> | "SQL") "%" ID("FOUND|NOTFOUND|ISOPEN|ROWCOUNT")
  | LOOKAHEAD(FunctionReference() "(") FunctionCall()
  | ObjectReference() // Might be a call to a parameter-less function.
}

ExpressionNode SqlCaseExpression():
{}
{
    "CASE" (SqlSimpleExpression() ("WHEN" SqlSimpleExpression() "THEN" SqlSimpleExpression())*
            | ("WHEN" SqlExpression() "THEN" SqlSimpleExpression())*
           )
    ["ELSE" SqlSimpleExpression()]
    "END"
}

void SqlCastExpression():
{}
{
    "CAST" "(" SqlExpression() "AS" BasicDataTypeDefinition() ")"
}

ExpressionNode TableColumn():
{}
{
    ObjectReference()
}

ExpressionNode ObjectName():
{}
{
    <S_IDENTIFIER>          {
        return nextOf(ExpressionNode.LITERAL, token.image, token.beginColumn);
    }
    | <S_QUOTED_IDENTIFIER> {
        return nextOf(ExpressionNode.LITERAL, token.image, token.beginColumn);
    }
}

CharSequence TNSName():
{
    StringBuilder name = new StringBuilder();
}
{
    <S_IDENTIFIER>      {name.append(token.image);}
    ("." <S_IDENTIFIER> {name.append(".").append(token.image);} )*
    {return name.toString();}
}

ExpressionNode Relop():
{}
{
    "="
  | "!" "="
  | "#"
  | LOOKAHEAD(2) ">" "="
  | ">"
  | LOOKAHEAD(2) "<" ">"
  | LOOKAHEAD(2) "<" "="
  | "<"
}

ExpressionNode TableName():
{
    ExpressionNode e;
}
{
    // table
    e=ObjectName()
    { return e; }
}

ExpressionNode ParameterList():
{}
{
    Parameter() ( "," Parameter() )*
}

ExpressionNode NumOrID():
{}
{
    <S_IDENTIFIER> | (["+" | "-"] <S_NUMBER>)
}

ExpressionNode Parameter():
{}
{
    <S_IDENTIFIER> [ ["IN"] ["OUT"] BasicDataTypeDefinition()
                             [(":=" | "DEFAULT" ) SqlExpression()] ]
}

ExpressionNode Arguments():
{}
{
    Argument() ("," Argument())*
}

ExpressionNode Argument():
{}
{
    [LOOKAHEAD(2) <S_IDENTIFIER> "=>"] SqlExpression()
}

ExpressionNode SelectStatement():
{ExpressionNode select, order;}
{
    select = SelectWithoutOrder()
    [ order = OrderByClause() ]
    {return select;}
}

ExpressionNode SelectWithoutOrder():
{ExpressionNode first, next;
 int connection = -1;}
{
    first = SelectSet() ((("UNION" {connection = 1;} ["ALL" {connection = 1;}]) | "INTERSECT" {connection = 3;} | "MINUS" {connection = 4;}) SelectSet())*
    { return first; }
}

ExpressionNode SelectSet():
{ExpressionNode select; }
{
    select = Select() | "(" select = SubQuery() ")"
    { return select; }
}

ExpressionNode Select():
{ from, where;}
{
    "SELECT" [ "ALL" | "DISTINCT" | "UNIQUE" ] SelectList()
    from = FromClause()
    [ where = WhereClause() ]
    { return nextOf()}
}

void SelectList():
{}
{
    "*" | SelectItem() ("," SelectItem())*
}

ExpressionNode SelectItem():
{}
{
    (
        LOOKAHEAD(2) ObjectName()".*" // table.*
      | LOOKAHEAD(4) ObjectName()"." ObjectName() ".*" // schema.table.*
      | SqlSimpleExpression() // column name or expression
    )
    [ [ "AS" ] SelectItemAlias()]
}

ExpressionNode SelectItemAlias():
{}
{
    ObjectName()
    // Some keywords are acceptable as aliases:
  | "RETURNING" | "WHEN"
}

ExpressionNode AnalyticFunction():
{}
{
    FunctionCall() [ "OVER" "(" AnalyticClause() ")" ]
}

ExpressionNode AnalyticClause():
{}
{
    [ QueryPartitionClause() ] [ OrderByClause() [ WindowingClause() ] ]
}

ExpressionNode QueryPartitionClause():
{}
{
    "PARTITION" "BY" SqlExpression() ( "," SqlExpression() )*
}

ExpressionNode WindowingClause():
{}
{
    ("ROWS" | "RANGE")
    ( "CURRENT" "ROW"
    | SqlSimpleExpression() ID("PRECEDING") // perhaps UNBOUNDED PRECEDING
    | "BETWEEN" ( "CURRENT" "ROW"
                | SqlSimpleExpression() ID("PRECEDING|FOLLOWING") // perhaps UNBOUNDED FOLLOWING
                )
          "AND" ( "CURRENT" "ROW"
                | SqlSimpleExpression() ID("PRECEDING|FOLLOWING") // perhaps UNBOUNDED PRECEDING
                )
    )
}

ExpressionNode IntoClause():
{}
{
   "INTO" DataItem() ("," DataItem())*
}

ExpressionNode DataItem():
{}
{
    (<S_IDENTIFIER> ["." <S_IDENTIFIER>] | BindVariable())
    [ "(" SqlSimpleExpression() ")" ] // collection subscript
}

ExpressionNode FromClause():
{}
{
    "FROM" TableReference() ( "," TableReference())*
}
ExpressionNode TableReference():
{}
{
    "ONLY" "(" QueryTableExpression() ")"
  | QueryTableExpression()
}

ExpressionNode QueryTableExpression():
{}
{
    (TableName() // might also be a query name
     | TableCollectionExpression()
     | LOOKAHEAD(3) "(" SubQuery() ")"
     | "(" TableReference() ")"
     | BindVariable() // not valid Sql, but appears in StatsPack Sql text
    )
    ["PX_GRANULE" "(" <S_NUMBER> "," <S_IDENTIFIER> "," <S_IDENTIFIER> ")"]
    ["SAMPLE" [ID("BLOCK")] "(" <S_NUMBER> ")"]
    [ObjectName()] // alias
    (Join())*
}

ExpressionNode TableCollectionExpression():
{}
{
    "TABLE" "(" SqlSimpleExpression() ")" [ "(" "+" ")" ]
}

ExpressionNode Join():
{}
{
    JoinType() ID("JOIN") TableReference() ("ON" SqlExpression())
}

ExpressionNode JoinType():
{}
{
    "INNER"
  | ("LEFT" | "RIGHT" | "FULL") ID("OUTER")
}

ExpressionNode ColumnName():
{}
{
    <S_IDENTIFIER>
}

ExpressionNode WhereClause():
{}
{
    "WHERE" SqlExpression()
}

ExpressionNode OrderByClause():
{}
{
    "ORDER" "BY" OrderByExpression() ("," OrderByExpression())*
}

ExpressionNode OrderByExpression():
{}
{
    SqlSimpleExpression()
    ["ASC" | "DESC"]
    ["NULLS" ID("LAST")]
}

ExpressionNode ExistsClause():
{}
{
    ["NOT"] "EXISTS" "(" SubQuery() ")"
}

ExpressionNode IntervalExpression():
{}
{
    ID("INTERVAL") SqlSimpleExpression()
    ( LOOKAHEAD({"DAY".equalsIgnoreCase(getToken(1).image)})
      ID("DAY") ["(" <S_NUMBER> ")"] "TO" ID("SECOND") ["(" <S_NUMBER> ")"]
    | ID("YEAR") ["(" <S_NUMBER> ")"] "TO" ID("MONTH") ["(" <S_NUMBER> ")"]
    )
}

ExpressionNode FunctionCall():
{}
{
    FunctionReference() (
        LOOKAHEAD({"TRIM".equalsIgnoreCase(lastObjectReference)}) TrimArguments()
      | LOOKAHEAD({"EXTRACT".equalsIgnoreCase(lastObjectReference)}) "(" DatetimeField() "FROM" SqlSimpleExpression() ")"
      | [ "(" [["ALL" | "DISTINCT" | "UNIQUE"] (FunctionArgumentList() | "*")] ")" ]
    )
    // "all/distinct/unique/*" are permitted only with aggregate functions,
    // but this parser allows their use with any function.
}

ExpressionNode FunctionReference():
{
    CharSequence name;
}
{
    name = ObjectReference()
    {functions.add(name.toUpperCase());}
}

ExpressionNode FunctionArgumentList():
{}
{
    FunctionArgument() ("," FunctionArgument())*
}

ExpressionNode FunctionArgument():
{}
{
    [LOOKAHEAD(2) <S_IDENTIFIER> "=>"] SqlExpression()
}

ExpressionNode TrimArguments():
{}
{
    "(" ( LOOKAHEAD({getToken(1).image.matches("(?i)LEADING|TRAILING|BOTH")})
            <S_IDENTIFIER> [SqlSimpleExpression()] "FROM" SqlSimpleExpression()
        | SqlSimpleExpression() ["FROM" SqlSimpleExpression()]
        )
    ")"
}

ExpressionNode DatetimeField():
{}
{
    <S_IDENTIFIER>
}

ExpressionNode ObjectReference():
{
    CharSequence s;
    StringBuilder name = new StringBuilder();
}
{
    s=ObjectName()       {name.append(s);}
    [ "." s=ObjectName() {name.append(".").append(s);}
    [ "." s=ObjectName() {name.append(".").append(s);}
    ]]
    [ "@" ("!" | s=TNSName()   {name.append("@").append(s);} )] // remote reference
    // The @! idiom is undocumented, but accepted by Oracle software.
    {return lastObjectReference = name.toString();}
}

ExpressionNode OuterJoinExpression():
{}
{
    TableColumn() "(" "+" ")"
}

ExpressionNode SubQuery():
{}
{
    SelectStatement()
}

/** Expect an <S_IDENTIFIER> with the given value. */
ExpressionNode ID(String id):
{}
{
    <S_IDENTIFIER>
    {
        if (!token.image.matches("(?i)" + id)) {
            throw new ParseException("Encountered " + token.image
                + " at line " + token.beginLine + ", column " + token.beginColumn + "."
                + "\nWas expecting: " + id);
        }
    }
}